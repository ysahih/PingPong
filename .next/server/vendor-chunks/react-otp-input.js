"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-otp-input";
exports.ids = ["vendor-chunks/react-otp-input"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-otp-input/lib/index.esm.js":
/*!*******************************************************!*\
  !*** ./node_modules/react-otp-input/lib/index.esm.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ OTPInput)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\n\nvar isStyleObject = function (obj) { return typeof obj === 'object' && obj !== null; };\nvar OTPInput = function (_a) {\n    var _b = _a.value, value = _b === void 0 ? '' : _b, _c = _a.numInputs, numInputs = _c === void 0 ? 4 : _c, onChange = _a.onChange, onPaste = _a.onPaste, renderInput = _a.renderInput, _d = _a.shouldAutoFocus, shouldAutoFocus = _d === void 0 ? false : _d, _e = _a.inputType, inputType = _e === void 0 ? 'text' : _e, renderSeparator = _a.renderSeparator, placeholder = _a.placeholder, containerStyle = _a.containerStyle, inputStyle = _a.inputStyle, _f = _a.skipDefaultStyles, skipDefaultStyles = _f === void 0 ? false : _f;\n    var _g = react__WEBPACK_IMPORTED_MODULE_0___default().useState(0), activeInput = _g[0], setActiveInput = _g[1];\n    var inputRefs = react__WEBPACK_IMPORTED_MODULE_0___default().useRef([]);\n    var getOTPValue = function () { return (value ? value.toString().split('') : []); };\n    var isInputNum = inputType === 'number' || inputType === 'tel';\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function () {\n        inputRefs.current = inputRefs.current.slice(0, numInputs);\n    }, [numInputs]);\n    react__WEBPACK_IMPORTED_MODULE_0___default().useEffect(function () {\n        var _a;\n        if (shouldAutoFocus) {\n            (_a = inputRefs.current[0]) === null || _a === void 0 ? void 0 : _a.focus();\n        }\n    }, [shouldAutoFocus]);\n    var getPlaceholderValue = function () {\n        if (typeof placeholder === 'string') {\n            if (placeholder.length === numInputs) {\n                return placeholder;\n            }\n            if (placeholder.length > 0) {\n                console.error('Length of the placeholder should be equal to the number of inputs.');\n            }\n        }\n        return undefined;\n    };\n    var isInputValueValid = function (value) {\n        var isTypeValid = isInputNum ? !isNaN(Number(value)) : typeof value === 'string';\n        return isTypeValid && value.trim().length === 1;\n    };\n    var handleChange = function (event) {\n        var value = event.target.value;\n        if (isInputValueValid(value)) {\n            changeCodeAtFocus(value);\n            focusInput(activeInput + 1);\n        }\n    };\n    var handleInputChange = function (event) {\n        var nativeEvent = event.nativeEvent;\n        var value = event.target.value;\n        if (!isInputValueValid(value)) {\n            // Pasting from the native autofill suggestion on a mobile device can pass\n            // the pasted string as one long input to one of the cells. This ensures\n            // that we handle the full input and not just the first character.\n            if (value.length === numInputs) {\n                var hasInvalidInput = value.split('').some(function (cellInput) { return !isInputValueValid(cellInput); });\n                if (!hasInvalidInput) {\n                    handleOTPChange(value.split(''));\n                    focusInput(numInputs - 1);\n                }\n            }\n            // @ts-expect-error - This was added previously to handle and edge case\n            // for dealing with keyCode \"229 Unidentified\" on Android. Check if this is\n            // still needed.\n            if (nativeEvent.data === null && nativeEvent.inputType === 'deleteContentBackward') {\n                event.preventDefault();\n                changeCodeAtFocus('');\n                focusInput(activeInput - 1);\n            }\n            // Clear the input if it's not valid value because firefox allows\n            // pasting non-numeric characters in a number type input\n            event.target.value = '';\n        }\n    };\n    var handleFocus = function (event) { return function (index) {\n        setActiveInput(index);\n        event.target.select();\n    }; };\n    var handleBlur = function () {\n        setActiveInput(activeInput - 1);\n    };\n    var handleKeyDown = function (event) {\n        var otp = getOTPValue();\n        if ([event.code, event.key].includes('Backspace')) {\n            event.preventDefault();\n            changeCodeAtFocus('');\n            focusInput(activeInput - 1);\n        }\n        else if (event.code === 'Delete') {\n            event.preventDefault();\n            changeCodeAtFocus('');\n        }\n        else if (event.code === 'ArrowLeft') {\n            event.preventDefault();\n            focusInput(activeInput - 1);\n        }\n        else if (event.code === 'ArrowRight') {\n            event.preventDefault();\n            focusInput(activeInput + 1);\n        }\n        // React does not trigger onChange when the same value is entered\n        // again. So we need to focus the next input manually in this case.\n        else if (event.key === otp[activeInput]) {\n            event.preventDefault();\n            focusInput(activeInput + 1);\n        }\n        else if (event.code === 'Spacebar' ||\n            event.code === 'Space' ||\n            event.code === 'ArrowUp' ||\n            event.code === 'ArrowDown') {\n            event.preventDefault();\n        }\n    };\n    var focusInput = function (index) {\n        var _a, _b;\n        var activeInput = Math.max(Math.min(numInputs - 1, index), 0);\n        if (inputRefs.current[activeInput]) {\n            (_a = inputRefs.current[activeInput]) === null || _a === void 0 ? void 0 : _a.focus();\n            (_b = inputRefs.current[activeInput]) === null || _b === void 0 ? void 0 : _b.select();\n            setActiveInput(activeInput);\n        }\n    };\n    var changeCodeAtFocus = function (value) {\n        var otp = getOTPValue();\n        otp[activeInput] = value[0];\n        handleOTPChange(otp);\n    };\n    var handleOTPChange = function (otp) {\n        var otpValue = otp.join('');\n        onChange(otpValue);\n    };\n    var handlePaste = function (event) {\n        var _a;\n        event.preventDefault();\n        var otp = getOTPValue();\n        var nextActiveInput = activeInput;\n        // Get pastedData in an array of max size (num of inputs - current position)\n        var pastedData = event.clipboardData\n            .getData('text/plain')\n            .slice(0, numInputs - activeInput)\n            .split('');\n        // Prevent pasting if the clipboard data contains non-numeric values for number inputs\n        if (isInputNum && pastedData.some(function (value) { return isNaN(Number(value)); })) {\n            return;\n        }\n        // Paste data from focused input onwards\n        for (var pos = 0; pos < numInputs; ++pos) {\n            if (pos >= activeInput && pastedData.length > 0) {\n                otp[pos] = (_a = pastedData.shift()) !== null && _a !== void 0 ? _a : '';\n                nextActiveInput++;\n            }\n        }\n        focusInput(nextActiveInput);\n        handleOTPChange(otp);\n    };\n    return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement(\"div\", { style: Object.assign({ display: 'flex', alignItems: 'center' }, isStyleObject(containerStyle) && containerStyle), className: typeof containerStyle === 'string' ? containerStyle : undefined, onPaste: onPaste }, Array.from({ length: numInputs }, function (_, index) { return index; }).map(function (index) {\n        var _a, _b, _c;\n        return (react__WEBPACK_IMPORTED_MODULE_0___default().createElement((react__WEBPACK_IMPORTED_MODULE_0___default().Fragment), { key: index },\n            renderInput({\n                value: (_a = getOTPValue()[index]) !== null && _a !== void 0 ? _a : '',\n                placeholder: (_c = (_b = getPlaceholderValue()) === null || _b === void 0 ? void 0 : _b[index]) !== null && _c !== void 0 ? _c : undefined,\n                ref: function (element) { return (inputRefs.current[index] = element); },\n                onChange: handleChange,\n                onFocus: function (event) { return handleFocus(event)(index); },\n                onBlur: handleBlur,\n                onKeyDown: handleKeyDown,\n                onPaste: handlePaste,\n                autoComplete: 'off',\n                'aria-label': \"Please enter OTP character \".concat(index + 1),\n                style: Object.assign(!skipDefaultStyles ? { width: '1em', textAlign: 'center' } : {}, isStyleObject(inputStyle) ? inputStyle : {}),\n                className: typeof inputStyle === 'string' ? inputStyle : undefined,\n                type: inputType,\n                inputMode: isInputNum ? 'numeric' : 'text',\n                onInput: handleInputChange,\n            }, index),\n            index < numInputs - 1 && (typeof renderSeparator === 'function' ? renderSeparator(index) : renderSeparator)));\n    })));\n};\n\n\n//# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3Qtb3RwLWlucHV0L2xpYi9pbmRleC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTBCOztBQUUxQixxQ0FBcUM7QUFDckM7QUFDQTtBQUNBLGFBQWEscURBQWM7QUFDM0Isb0JBQW9CLG1EQUFZO0FBQ2hDLG9DQUFvQztBQUNwQztBQUNBLElBQUksc0RBQWU7QUFDbkI7QUFDQSxLQUFLO0FBQ0wsSUFBSSxzREFBZTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRkFBa0YsdUNBQXVDO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCw4QkFBOEI7QUFDM0Y7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGlCQUFpQjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSwwREFBbUIsVUFBVSx1QkFBdUIsdUNBQXVDLGtKQUFrSixlQUFlLG1CQUFtQix3QkFBd0IsZUFBZTtBQUNsVTtBQUNBLGdCQUFnQiwwREFBbUIsQ0FBQyx1REFBYyxJQUFJLFlBQVk7QUFDbEU7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLDhDQUE4QztBQUN4RjtBQUNBLDRDQUE0QyxtQ0FBbUM7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCxvQ0FBb0MsSUFBSSw2Q0FBNkM7QUFDako7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxLQUFLO0FBQ0w7O0FBRStCO0FBQy9CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvLi9ub2RlX21vZHVsZXMvcmVhY3Qtb3RwLWlucHV0L2xpYi9pbmRleC5lc20uanM/NDU4YiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuXG52YXIgaXNTdHlsZU9iamVjdCA9IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbDsgfTtcbnZhciBPVFBJbnB1dCA9IGZ1bmN0aW9uIChfYSkge1xuICAgIHZhciBfYiA9IF9hLnZhbHVlLCB2YWx1ZSA9IF9iID09PSB2b2lkIDAgPyAnJyA6IF9iLCBfYyA9IF9hLm51bUlucHV0cywgbnVtSW5wdXRzID0gX2MgPT09IHZvaWQgMCA/IDQgOiBfYywgb25DaGFuZ2UgPSBfYS5vbkNoYW5nZSwgb25QYXN0ZSA9IF9hLm9uUGFzdGUsIHJlbmRlcklucHV0ID0gX2EucmVuZGVySW5wdXQsIF9kID0gX2Euc2hvdWxkQXV0b0ZvY3VzLCBzaG91bGRBdXRvRm9jdXMgPSBfZCA9PT0gdm9pZCAwID8gZmFsc2UgOiBfZCwgX2UgPSBfYS5pbnB1dFR5cGUsIGlucHV0VHlwZSA9IF9lID09PSB2b2lkIDAgPyAndGV4dCcgOiBfZSwgcmVuZGVyU2VwYXJhdG9yID0gX2EucmVuZGVyU2VwYXJhdG9yLCBwbGFjZWhvbGRlciA9IF9hLnBsYWNlaG9sZGVyLCBjb250YWluZXJTdHlsZSA9IF9hLmNvbnRhaW5lclN0eWxlLCBpbnB1dFN0eWxlID0gX2EuaW5wdXRTdHlsZSwgX2YgPSBfYS5za2lwRGVmYXVsdFN0eWxlcywgc2tpcERlZmF1bHRTdHlsZXMgPSBfZiA9PT0gdm9pZCAwID8gZmFsc2UgOiBfZjtcbiAgICB2YXIgX2cgPSBSZWFjdC51c2VTdGF0ZSgwKSwgYWN0aXZlSW5wdXQgPSBfZ1swXSwgc2V0QWN0aXZlSW5wdXQgPSBfZ1sxXTtcbiAgICB2YXIgaW5wdXRSZWZzID0gUmVhY3QudXNlUmVmKFtdKTtcbiAgICB2YXIgZ2V0T1RQVmFsdWUgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAodmFsdWUgPyB2YWx1ZS50b1N0cmluZygpLnNwbGl0KCcnKSA6IFtdKTsgfTtcbiAgICB2YXIgaXNJbnB1dE51bSA9IGlucHV0VHlwZSA9PT0gJ251bWJlcicgfHwgaW5wdXRUeXBlID09PSAndGVsJztcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xuICAgICAgICBpbnB1dFJlZnMuY3VycmVudCA9IGlucHV0UmVmcy5jdXJyZW50LnNsaWNlKDAsIG51bUlucHV0cyk7XG4gICAgfSwgW251bUlucHV0c10pO1xuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKHNob3VsZEF1dG9Gb2N1cykge1xuICAgICAgICAgICAgKF9hID0gaW5wdXRSZWZzLmN1cnJlbnRbMF0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5mb2N1cygpO1xuICAgICAgICB9XG4gICAgfSwgW3Nob3VsZEF1dG9Gb2N1c10pO1xuICAgIHZhciBnZXRQbGFjZWhvbGRlclZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodHlwZW9mIHBsYWNlaG9sZGVyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgaWYgKHBsYWNlaG9sZGVyLmxlbmd0aCA9PT0gbnVtSW5wdXRzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBsYWNlaG9sZGVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdMZW5ndGggb2YgdGhlIHBsYWNlaG9sZGVyIHNob3VsZCBiZSBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIGlucHV0cy4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG4gICAgdmFyIGlzSW5wdXRWYWx1ZVZhbGlkID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHZhciBpc1R5cGVWYWxpZCA9IGlzSW5wdXROdW0gPyAhaXNOYU4oTnVtYmVyKHZhbHVlKSkgOiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xuICAgICAgICByZXR1cm4gaXNUeXBlVmFsaWQgJiYgdmFsdWUudHJpbSgpLmxlbmd0aCA9PT0gMTtcbiAgICB9O1xuICAgIHZhciBoYW5kbGVDaGFuZ2UgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gZXZlbnQudGFyZ2V0LnZhbHVlO1xuICAgICAgICBpZiAoaXNJbnB1dFZhbHVlVmFsaWQodmFsdWUpKSB7XG4gICAgICAgICAgICBjaGFuZ2VDb2RlQXRGb2N1cyh2YWx1ZSk7XG4gICAgICAgICAgICBmb2N1c0lucHV0KGFjdGl2ZUlucHV0ICsgMSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBoYW5kbGVJbnB1dENoYW5nZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgbmF0aXZlRXZlbnQgPSBldmVudC5uYXRpdmVFdmVudDtcbiAgICAgICAgdmFyIHZhbHVlID0gZXZlbnQudGFyZ2V0LnZhbHVlO1xuICAgICAgICBpZiAoIWlzSW5wdXRWYWx1ZVZhbGlkKHZhbHVlKSkge1xuICAgICAgICAgICAgLy8gUGFzdGluZyBmcm9tIHRoZSBuYXRpdmUgYXV0b2ZpbGwgc3VnZ2VzdGlvbiBvbiBhIG1vYmlsZSBkZXZpY2UgY2FuIHBhc3NcbiAgICAgICAgICAgIC8vIHRoZSBwYXN0ZWQgc3RyaW5nIGFzIG9uZSBsb25nIGlucHV0IHRvIG9uZSBvZiB0aGUgY2VsbHMuIFRoaXMgZW5zdXJlc1xuICAgICAgICAgICAgLy8gdGhhdCB3ZSBoYW5kbGUgdGhlIGZ1bGwgaW5wdXQgYW5kIG5vdCBqdXN0IHRoZSBmaXJzdCBjaGFyYWN0ZXIuXG4gICAgICAgICAgICBpZiAodmFsdWUubGVuZ3RoID09PSBudW1JbnB1dHMpIHtcbiAgICAgICAgICAgICAgICB2YXIgaGFzSW52YWxpZElucHV0ID0gdmFsdWUuc3BsaXQoJycpLnNvbWUoZnVuY3Rpb24gKGNlbGxJbnB1dCkgeyByZXR1cm4gIWlzSW5wdXRWYWx1ZVZhbGlkKGNlbGxJbnB1dCk7IH0pO1xuICAgICAgICAgICAgICAgIGlmICghaGFzSW52YWxpZElucHV0KSB7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZU9UUENoYW5nZSh2YWx1ZS5zcGxpdCgnJykpO1xuICAgICAgICAgICAgICAgICAgICBmb2N1c0lucHV0KG51bUlucHV0cyAtIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgLSBUaGlzIHdhcyBhZGRlZCBwcmV2aW91c2x5IHRvIGhhbmRsZSBhbmQgZWRnZSBjYXNlXG4gICAgICAgICAgICAvLyBmb3IgZGVhbGluZyB3aXRoIGtleUNvZGUgXCIyMjkgVW5pZGVudGlmaWVkXCIgb24gQW5kcm9pZC4gQ2hlY2sgaWYgdGhpcyBpc1xuICAgICAgICAgICAgLy8gc3RpbGwgbmVlZGVkLlxuICAgICAgICAgICAgaWYgKG5hdGl2ZUV2ZW50LmRhdGEgPT09IG51bGwgJiYgbmF0aXZlRXZlbnQuaW5wdXRUeXBlID09PSAnZGVsZXRlQ29udGVudEJhY2t3YXJkJykge1xuICAgICAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgY2hhbmdlQ29kZUF0Rm9jdXMoJycpO1xuICAgICAgICAgICAgICAgIGZvY3VzSW5wdXQoYWN0aXZlSW5wdXQgLSAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIENsZWFyIHRoZSBpbnB1dCBpZiBpdCdzIG5vdCB2YWxpZCB2YWx1ZSBiZWNhdXNlIGZpcmVmb3ggYWxsb3dzXG4gICAgICAgICAgICAvLyBwYXN0aW5nIG5vbi1udW1lcmljIGNoYXJhY3RlcnMgaW4gYSBudW1iZXIgdHlwZSBpbnB1dFxuICAgICAgICAgICAgZXZlbnQudGFyZ2V0LnZhbHVlID0gJyc7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBoYW5kbGVGb2N1cyA9IGZ1bmN0aW9uIChldmVudCkgeyByZXR1cm4gZnVuY3Rpb24gKGluZGV4KSB7XG4gICAgICAgIHNldEFjdGl2ZUlucHV0KGluZGV4KTtcbiAgICAgICAgZXZlbnQudGFyZ2V0LnNlbGVjdCgpO1xuICAgIH07IH07XG4gICAgdmFyIGhhbmRsZUJsdXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNldEFjdGl2ZUlucHV0KGFjdGl2ZUlucHV0IC0gMSk7XG4gICAgfTtcbiAgICB2YXIgaGFuZGxlS2V5RG93biA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgb3RwID0gZ2V0T1RQVmFsdWUoKTtcbiAgICAgICAgaWYgKFtldmVudC5jb2RlLCBldmVudC5rZXldLmluY2x1ZGVzKCdCYWNrc3BhY2UnKSkge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGNoYW5nZUNvZGVBdEZvY3VzKCcnKTtcbiAgICAgICAgICAgIGZvY3VzSW5wdXQoYWN0aXZlSW5wdXQgLSAxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChldmVudC5jb2RlID09PSAnRGVsZXRlJykge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGNoYW5nZUNvZGVBdEZvY3VzKCcnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChldmVudC5jb2RlID09PSAnQXJyb3dMZWZ0Jykge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgICAgIGZvY3VzSW5wdXQoYWN0aXZlSW5wdXQgLSAxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChldmVudC5jb2RlID09PSAnQXJyb3dSaWdodCcpIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBmb2N1c0lucHV0KGFjdGl2ZUlucHV0ICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVhY3QgZG9lcyBub3QgdHJpZ2dlciBvbkNoYW5nZSB3aGVuIHRoZSBzYW1lIHZhbHVlIGlzIGVudGVyZWRcbiAgICAgICAgLy8gYWdhaW4uIFNvIHdlIG5lZWQgdG8gZm9jdXMgdGhlIG5leHQgaW5wdXQgbWFudWFsbHkgaW4gdGhpcyBjYXNlLlxuICAgICAgICBlbHNlIGlmIChldmVudC5rZXkgPT09IG90cFthY3RpdmVJbnB1dF0pIHtcbiAgICAgICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBmb2N1c0lucHV0KGFjdGl2ZUlucHV0ICsgMSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXZlbnQuY29kZSA9PT0gJ1NwYWNlYmFyJyB8fFxuICAgICAgICAgICAgZXZlbnQuY29kZSA9PT0gJ1NwYWNlJyB8fFxuICAgICAgICAgICAgZXZlbnQuY29kZSA9PT0gJ0Fycm93VXAnIHx8XG4gICAgICAgICAgICBldmVudC5jb2RlID09PSAnQXJyb3dEb3duJykge1xuICAgICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIGZvY3VzSW5wdXQgPSBmdW5jdGlvbiAoaW5kZXgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdmFyIGFjdGl2ZUlucHV0ID0gTWF0aC5tYXgoTWF0aC5taW4obnVtSW5wdXRzIC0gMSwgaW5kZXgpLCAwKTtcbiAgICAgICAgaWYgKGlucHV0UmVmcy5jdXJyZW50W2FjdGl2ZUlucHV0XSkge1xuICAgICAgICAgICAgKF9hID0gaW5wdXRSZWZzLmN1cnJlbnRbYWN0aXZlSW5wdXRdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZm9jdXMoKTtcbiAgICAgICAgICAgIChfYiA9IGlucHV0UmVmcy5jdXJyZW50W2FjdGl2ZUlucHV0XSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNlbGVjdCgpO1xuICAgICAgICAgICAgc2V0QWN0aXZlSW5wdXQoYWN0aXZlSW5wdXQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgY2hhbmdlQ29kZUF0Rm9jdXMgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIG90cCA9IGdldE9UUFZhbHVlKCk7XG4gICAgICAgIG90cFthY3RpdmVJbnB1dF0gPSB2YWx1ZVswXTtcbiAgICAgICAgaGFuZGxlT1RQQ2hhbmdlKG90cCk7XG4gICAgfTtcbiAgICB2YXIgaGFuZGxlT1RQQ2hhbmdlID0gZnVuY3Rpb24gKG90cCkge1xuICAgICAgICB2YXIgb3RwVmFsdWUgPSBvdHAuam9pbignJyk7XG4gICAgICAgIG9uQ2hhbmdlKG90cFZhbHVlKTtcbiAgICB9O1xuICAgIHZhciBoYW5kbGVQYXN0ZSA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHZhciBvdHAgPSBnZXRPVFBWYWx1ZSgpO1xuICAgICAgICB2YXIgbmV4dEFjdGl2ZUlucHV0ID0gYWN0aXZlSW5wdXQ7XG4gICAgICAgIC8vIEdldCBwYXN0ZWREYXRhIGluIGFuIGFycmF5IG9mIG1heCBzaXplIChudW0gb2YgaW5wdXRzIC0gY3VycmVudCBwb3NpdGlvbilcbiAgICAgICAgdmFyIHBhc3RlZERhdGEgPSBldmVudC5jbGlwYm9hcmREYXRhXG4gICAgICAgICAgICAuZ2V0RGF0YSgndGV4dC9wbGFpbicpXG4gICAgICAgICAgICAuc2xpY2UoMCwgbnVtSW5wdXRzIC0gYWN0aXZlSW5wdXQpXG4gICAgICAgICAgICAuc3BsaXQoJycpO1xuICAgICAgICAvLyBQcmV2ZW50IHBhc3RpbmcgaWYgdGhlIGNsaXBib2FyZCBkYXRhIGNvbnRhaW5zIG5vbi1udW1lcmljIHZhbHVlcyBmb3IgbnVtYmVyIGlucHV0c1xuICAgICAgICBpZiAoaXNJbnB1dE51bSAmJiBwYXN0ZWREYXRhLnNvbWUoZnVuY3Rpb24gKHZhbHVlKSB7IHJldHVybiBpc05hTihOdW1iZXIodmFsdWUpKTsgfSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBQYXN0ZSBkYXRhIGZyb20gZm9jdXNlZCBpbnB1dCBvbndhcmRzXG4gICAgICAgIGZvciAodmFyIHBvcyA9IDA7IHBvcyA8IG51bUlucHV0czsgKytwb3MpIHtcbiAgICAgICAgICAgIGlmIChwb3MgPj0gYWN0aXZlSW5wdXQgJiYgcGFzdGVkRGF0YS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgb3RwW3Bvc10gPSAoX2EgPSBwYXN0ZWREYXRhLnNoaWZ0KCkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnO1xuICAgICAgICAgICAgICAgIG5leHRBY3RpdmVJbnB1dCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvY3VzSW5wdXQobmV4dEFjdGl2ZUlucHV0KTtcbiAgICAgICAgaGFuZGxlT1RQQ2hhbmdlKG90cCk7XG4gICAgfTtcbiAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBzdHlsZTogT2JqZWN0LmFzc2lnbih7IGRpc3BsYXk6ICdmbGV4JywgYWxpZ25JdGVtczogJ2NlbnRlcicgfSwgaXNTdHlsZU9iamVjdChjb250YWluZXJTdHlsZSkgJiYgY29udGFpbmVyU3R5bGUpLCBjbGFzc05hbWU6IHR5cGVvZiBjb250YWluZXJTdHlsZSA9PT0gJ3N0cmluZycgPyBjb250YWluZXJTdHlsZSA6IHVuZGVmaW5lZCwgb25QYXN0ZTogb25QYXN0ZSB9LCBBcnJheS5mcm9tKHsgbGVuZ3RoOiBudW1JbnB1dHMgfSwgZnVuY3Rpb24gKF8sIGluZGV4KSB7IHJldHVybiBpbmRleDsgfSkubWFwKGZ1bmN0aW9uIChpbmRleCkge1xuICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCB7IGtleTogaW5kZXggfSxcbiAgICAgICAgICAgIHJlbmRlcklucHV0KHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogKF9hID0gZ2V0T1RQVmFsdWUoKVtpbmRleF0pICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnLFxuICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyOiAoX2MgPSAoX2IgPSBnZXRQbGFjZWhvbGRlclZhbHVlKCkpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltpbmRleF0pICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICByZWY6IGZ1bmN0aW9uIChlbGVtZW50KSB7IHJldHVybiAoaW5wdXRSZWZzLmN1cnJlbnRbaW5kZXhdID0gZWxlbWVudCk7IH0sXG4gICAgICAgICAgICAgICAgb25DaGFuZ2U6IGhhbmRsZUNoYW5nZSxcbiAgICAgICAgICAgICAgICBvbkZvY3VzOiBmdW5jdGlvbiAoZXZlbnQpIHsgcmV0dXJuIGhhbmRsZUZvY3VzKGV2ZW50KShpbmRleCk7IH0sXG4gICAgICAgICAgICAgICAgb25CbHVyOiBoYW5kbGVCbHVyLFxuICAgICAgICAgICAgICAgIG9uS2V5RG93bjogaGFuZGxlS2V5RG93bixcbiAgICAgICAgICAgICAgICBvblBhc3RlOiBoYW5kbGVQYXN0ZSxcbiAgICAgICAgICAgICAgICBhdXRvQ29tcGxldGU6ICdvZmYnLFxuICAgICAgICAgICAgICAgICdhcmlhLWxhYmVsJzogXCJQbGVhc2UgZW50ZXIgT1RQIGNoYXJhY3RlciBcIi5jb25jYXQoaW5kZXggKyAxKSxcbiAgICAgICAgICAgICAgICBzdHlsZTogT2JqZWN0LmFzc2lnbighc2tpcERlZmF1bHRTdHlsZXMgPyB7IHdpZHRoOiAnMWVtJywgdGV4dEFsaWduOiAnY2VudGVyJyB9IDoge30sIGlzU3R5bGVPYmplY3QoaW5wdXRTdHlsZSkgPyBpbnB1dFN0eWxlIDoge30pLFxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogdHlwZW9mIGlucHV0U3R5bGUgPT09ICdzdHJpbmcnID8gaW5wdXRTdHlsZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICB0eXBlOiBpbnB1dFR5cGUsXG4gICAgICAgICAgICAgICAgaW5wdXRNb2RlOiBpc0lucHV0TnVtID8gJ251bWVyaWMnIDogJ3RleHQnLFxuICAgICAgICAgICAgICAgIG9uSW5wdXQ6IGhhbmRsZUlucHV0Q2hhbmdlLFxuICAgICAgICAgICAgfSwgaW5kZXgpLFxuICAgICAgICAgICAgaW5kZXggPCBudW1JbnB1dHMgLSAxICYmICh0eXBlb2YgcmVuZGVyU2VwYXJhdG9yID09PSAnZnVuY3Rpb24nID8gcmVuZGVyU2VwYXJhdG9yKGluZGV4KSA6IHJlbmRlclNlcGFyYXRvcikpKTtcbiAgICB9KSkpO1xufTtcblxuZXhwb3J0IHsgT1RQSW5wdXQgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-otp-input/lib/index.esm.js\n");

/***/ })

};
;